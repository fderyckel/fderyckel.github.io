{
  "hash": "965d7ab96ead39a3f68a9beffd399f6b",
  "result": {
    "markdown": "---\ntitle: \"Random Behavior of Financial Assets\"\nauthor: \"Francois de Ryckel\"\ndate: \"2023-04-18\"\ndescription: 'We explore one of the main assumption of quantitative finance: assets returns are random.'\ncategories: [R-code, quant-finance]\neditor: source\nimage: 'histogram-of-returns.png'\ndate-modified: \"2023-04-20\"\n---\n\n\nOne of the main pillar of quantitative finance is the assumption that assets' returns behave in a random manner.  Assets returns are normally distributed.  It is a poor assumption as asset's return are usually not normally distributed (fat tails, skewness, etc.), but it is one that is considered when approaching finance with a quantitative finance. Check [this post](../normality-returns/index.qmd) on the normality of assets returns for a deeper dive into how random (or not) are assets returns. \n\n# Discrete approach  \n\n$$R_i = \\frac{S_{i+1}-S_i}{S_i}$$ {#eq-ret1}\n$$\\bar{R} = \\frac{\\sum_{i=1}^{n} R_i}{n}$$\n\n* $R_i$ = return of an asset at time i\n* $S_i$ = price of an asset at time i\n\nIf returns are normally distributed, we could re-write @eq-ret1 as \n$$R_i = \\frac{S_{i+1} - S_i}{S_i} = \\bar{R} + std \\cdot \\phi$$ {#eq-ret2}\n\n* Std of returns (std): $\\sqrt{\\frac{1}{n-1} \\sum_{i=1}^{n}(R_i - \\bar{R})^2}$\n* $\\phi$ is just a number taken from the normal distribution with mean = 0 and std = 1 \n* $\\phi = \\frac{1}{\\sqrt{2 \\pi}} \\cdot e^{- \\frac{x^2}{2}}$ \n\n# Continuous approach \n\nReturns should scale with time. \n\nMean returns = $\\mu \\cdot \\delta t$\n\n* $\\mu$ = Annualized means returns on a continuous basis (usually not known, or hard to know)\n* $\\delta t$ = a small time increment \n\n## Ignoring randomness \n\n$$R_i = \\frac{S_{i+1} - S_i}{S_i} = mean  = \\mu \\delta t$$\n$$S_{i+1} - S_i= S_i \\mu \\delta t$$ \n$$S_{i+1} = S_i \\cdot (1 +  \\mu \\delta t)$$ {#eq-asset-price1}\n\n\nWe could also rewrite @eq-asset-price1 so it depends of the initial (starting) price, instead of the previous price.  \n\n$$S_n = S_0 (1+\\mu \\delta t)^n$$\n\nUsing natural log: \n\n$S_n = S_0 e^{log (1+\\mu \\delta t)^n} = S_0 e^{n \\cdot log{(1+\\mu \\delta t)}}$ \n\nWe could argue that $log(1+\\mu \\delta t) \\approx \\mu \\delta t$ as $log(1+x) \\approx x$ for small values of x. \n\n$$S_n \\approx S_0 \\cdot e^{n \\mu \\delta t}$$ {#eq-asset-price2} \n\nNow, $n \\cdot \\delta t$ is the same as $t$.  Hence, \n\n::: {.callout-tip appearance=\"minimal\"}\n$$S(t) \\approx S_0 \\cdot e^{\\mu t}$$ \n::: \n\n## Considering randomness \n\nLet's restart with @eq-ret2\n\n$$R_i = \\frac{S_{i+1} - S_i}{S_i} = \\bar{R} + std \\cdot \\phi = \\mu \\delta t + \\sigma \\phi \\delta t^{1/2}$$\n$$S_{i+1} - S_i= S_i \\mu \\delta t + S_i \\sigma \\phi \\delta t^{1/2}$$ {#eq-asset-price2}\n\n::: {.callout-tip appearance=\"minimal\"} \n$$S_{i+1} = S_i \\cdot (1 +  \\mu \\delta t +  \\sigma \\phi \\sqrt{\\delta t})$$ {#eq-asset-price3}\n\nThis last @eq-asset-price3 is the basis for Monte-Carlo simulation. \n\n* Notice the standard deviation of return: $\\sigma \\sqrt{\\delta t}$\n* unit of $\\mu = \\frac{1}{t}$ \n* unit of $\\sigma = \\frac{1}{\\sqrt{t}}$\n* this is because we can only add variance together (no sd).  For independent variable X and Y: $Var(X+Y) = Var(X) + Var(Y)$\n* the standard deviation of returns scale up with the square root of the time step. \n:::\n\n## Going to continuous time \n\nRestarting from @eq-asset-price2 : \n$$S_{i+1} - S_i= S_i \\mu \\delta t + S_i \\sigma \\sqrt{\\delta t} \\phi$$ \n\n* $S_{i+1} - S_i = dS$\n* $S_i = S(t)$\n* $\\delta t = dt$ \n* $\\phi \\sqrt{\\delta t} = dX$ where $dX$ is a random variable with mean = 0 and variance = dt.  Hence $E[dX] = 0$ and $E[(dX)^2] = dt$ \n\n::: {.callout-tip appearance=\"minimal\"}\n$$dS = S \\mu dt + S \\sigma dX$$ \nThis stochastic differential equation on the change of prices assume: \n\n* returns are treated as random \n* returns are assumed to be normally distributed (again not totally exact) \n* prices (S) are modelled as a log-normal walk (SDE) \n* $\\mu$ is the drift rate or growth rate \n* because of the different scaling of time ($t$ and $\\sqrt{t}$), on a short time frame, drift is negligible and volatility matters. \n::: \n\n\n\n# Practice in R \n\nLet's use the above notes with the ticker SBUX as a financial asset.   \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)    # read_csv()\nlibrary(dplyr)    # select(), filter(), mutate()\nlibrary(tidyr)    # drop_na()\n\ndf <- read_csv('../../../raw_data/SBUX.csv') |> \n  select(date, adjClose) |> \n  filter(date > '2019-07-01') |> drop_na() |>\n  mutate(ret = (adjClose - lag(adjClose)) / lag(adjClose))\n\nr_bar = mean(df$ret, na.rm = T)\nstdev = sd(df$ret, na.rm = T)\n\ndelta_t = 1/252\n\nmu = r_bar / delta_t\nsigma = stdev / sqrt(delta_t)\n\nr_bar\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -1.073652e-06\n```\n:::\n\n```{.r .cell-code}\nstdev\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.02092624\n```\n:::\n:::\n\n\nKnowing the average daily return of SBUX over the last 3-ish year and using $\\bar{R} = \\mu \\delta t$ , or $\\mu = \\frac{\\bar{R}}{\\delta t}$ and in our case $\\delta t = \\frac{1}{252}$; we find the average annualized returns $\\mu$ is: -0.027 % with standard deviation $\\sigma$ of 33.2 % annualized. \n\nWe could plot the returns and the std of returns\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n\nggplot(df |> drop_na(), aes(x = date, y = ret)) + \n  geom_line() + \n  geom_hline(yintercept = stdev, linetype = 'dotted', color = 'red', linewidth= 0.8) + \n  geom_hline(yintercept = -stdev, linetype = 'dotted', color = 'red', linewidth = 0.8) + \n  geom_hline(yintercept = 2*stdev, linetype = 'dotted', color = 'red', linewidth= 1) + \n  geom_hline(yintercept = -2*stdev, linetype = 'dotted', color = 'red', linewidth = 1) + \n  xlab(label = 'Date') + ylab(label = 'Daily returns') + \n  labs(title = 'Daily returns')\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nWe could standardized the returns (aka ensure they have a mean = 0 and std = 1) and compare it to the standard normal distribution. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf1 <- df |> \n  mutate(std_ret = (ret - r_bar) / stdev) |> \n  drop_na()\n\nggplot(df1, aes(std_ret)) + \n  geom_histogram(aes(y = ..density..), alpha = 0.3, fill = 'blue', binwidth = 0.5) + \n  stat_function(fun = dnorm, n = 101, args = list(mean = 0, sd = 1), color = 'red', size = 1) +\n  scale_y_continuous() + \n  scale_x_continuous(limits = c(-5, 5), n.breaks = 9)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nThis graph exemplifies what is very common with asset returns: fat tail, and under representation of returns just outside the mean. We discuss this further in our post: [The normality of asset returns](../normality-returns/index.qmd)\n\n## The Euler-Maruyana Method to compute the SDE \n\nWe start with @eq-asset-price3 : $S_{i+1} = S_i \\cdot (1 +  \\mu \\delta t +  \\sigma \\phi \\sqrt{\\delta t})$\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create one simulation for price \nndays <- 252 \nprice <- c()\nprice[1] <- last(df$adjClose)\n\nphi = rnorm(ndays, mean = 0, sd = 1)\n\nfor (i in 2:ndays){ \n  price[i] = price[i-1] * (1 + mu * delta_t + sigma * phi[i] * sqrt(delta_t))\n}\n\nyo <- tibble(x = 1:ndays, price = price)\nggplot(yo, aes(x, price)) + \n  geom_line()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nWe can now create 100's such simulations re-using previous code in a function. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreate_price_simul <- function(x) {\n  price <- c() \n  price[1] <- last(df$adjClose) \n  phi = rnorm(ndays, mean = 0, sd = 1) \n  for (i in 2:ndays){ \n    price[i] = price[i-1] * (1 + mu * delta_t + sigma * phi[i] * sqrt(delta_t)) \n    } \n  yo <- tibble(x = 1:ndays, price = price)\n  return(yo)\n}\n\nlibrary(purrr)      # map()\nlibrary(RColorBrewer)\n\nnum_of_simul <- 100\ndf1 <- tibble(simul_num = 1:num_of_simul) |> \n  mutate(prices = map(simul_num, create_price_simul))\n\nyo <- df1 |> unnest(cols = c(prices))\n\ngetPalette = colorRampPalette(brewer.pal(9, \"Set1\"))\ncolourCount = num_of_simul\nggplot(yo, aes(x, price, group = simul_num)) + \n  scale_fill_manual(values = colorRampPalette(brewer.pal(9, \"Accent\"))(colourCount)) +\n  geom_line(aes(color = simul_num)) + \n  theme(legend.position = 'none')\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in brewer.pal(9, \"Accent\"): n too large, allowed maximum for palette Accent is 8\nReturning the palette you asked for with that many colors\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}