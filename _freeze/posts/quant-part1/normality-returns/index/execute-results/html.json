{
  "hash": "8e8e37d6b38e714bcf73fc071e33d2bb",
  "result": {
    "markdown": "---\ntitle: \"02 - Normality of asset returns\"\nauthor: \"Francois de Ryckel\"\ndate: \"2023-04-19\"\ndescription: 'Checking the normality of asset returns visually and quantitatively.'\ncategories: [Normal Distribution, qq-plot, Kurtosis, Skewness]\neditor: source\nimage: qqplot-spy.png\ndate-modified: '2023-11-16'\n---\n\n::: {.cell}\n\n:::\n\n\n# Introduction\n\nAs mentioned in one of our [previous posts](../random-behavior-assets/index.qmd), we know that in quantitative finance, assets returns are assumed to be random. That being said they are not totally normally distributed. This post is to digg in a bit further in assessing the normality (or non-normality) of equity returns.\n\nAs reminder, a dataset can be said to be normally distributed if its probability density function can be modelled by $$P(X = x) = \\frac{1}{\\sigma \\sqrt{2 \\pi}} \\cdot e^{-\\frac{(x-\\mu)^2}{2 \\sigma^2}}$$\n\nWhen testing for normality, there are many ways to get there.\n\n-   Visual ways: histogram, density plot and QQ-plots\\\n-   Using Skewness or Kurtosis\n-   Statistical tests such as the Shapiro-Wilk test (small to medium sample size, $n \\leq 300$) or the Kolmogorov-Smirnov test\n\nLet's start by considering an ETF (low-ish volatility) like the SPY500.\\\nTo better illustrate our point, we'll also consider a fictitious stock with random and almost perfectly normally distributed returns.\n\nFrom previous post, returns can be explained with a drift rate + some randomness: $$R_i = \\mu \\delta t + \\phi \\sigma \\delta t^{1/2}$$\n\n# Comparing SPY returns with a similar imaginary stock\n\nLet's make some assumptions on how to get the drift rate and volatility of SPY. Using all the trading sessions since 01 Jan 2020, we'll use the mean historical returns and standard deviation of returns as drift and volatility.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_spy <- read_csv('../../../raw_data/SPY.csv') |> \n  select(date, adjClose) |> \n  arrange(date) |> \n  mutate(return = log(adjClose / lag(adjClose))) |> \n  filter(date > '2020-01-01')\n\ndrift = mean(df_spy$return) \nsigma = sd(df_spy$return) \n```\n:::\n\n\nSo over the last 3-ish years, SPY had an annualized drift rate of 9.04% with an volatility of 24.4%\n\nLet's consider now an imaginary stock with a similar drift rate and standard deviation as SPY.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(21042023)\nphi = rnorm(nrow(df_spy), mean = 0, sd = 1)   # create randomness from a normal distribution\ndf <- tibble(time = 1:length(phi),            \n             phi = phi, \n             return = drift + sigma * phi)    # create the return as drift + randomness \n\nprices = c(100)\nfor (i in 2:(nrow(df))) {\n  prices[i] = prices[i-1] * (1 + df$return[i])  #create a vector of prices based on the returns\n}\n\ndf <- add_column(df, prices)\n```\n:::\n\n\nLet's have a quick check that indeed mean and standard deviation of returns are similar. \n\n|                  | Drift                    | Volatility             |\n|------------------|--------------------------|------------------------|\n| SPY              | 3.6\\times 10^{-4} | 0.0152     |\n| Fictitious Asset | 7.3\\times 10^{-4}     | 0.0154 |\n\n: Summary of first 2 moments for both assets\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(df, aes(x = time, y = prices)) + \n  geom_line() + \n  labs(title = 'Imaginary Stock', \n       subtitle = 'Same drift as volatility as SPY')\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n\n```{.r .cell-code}\nggplot(df_spy, aes(x = date, y = adjClose)) + \n  geom_line() + \n  labs(title = 'SPY')\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-2.png){width=672}\n:::\n:::\n\n\n# Visual checks on imaginary stock vs SPY\n\nUsual visual checks for normality are the histogram and the QQ-plot.\n\n## Histograms\n\nLet's see how well the returns stack to our imaginary stock (with close to perfect pseudo-randomness)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(df, aes(return)) + \n  geom_histogram(aes(y = after_stat(density)), alpha = 0.3, fill = 'blue') + \n  geom_density() + \n  stat_function(fun = dnorm, n = nrow(df), args = list(mean = drift, sd = sigma), color = 'red', size = 1) +\n  scale_y_continuous() + \n  scale_x_continuous(limits = c(-0.055, 0.055), n.breaks = 9)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nThe black line is the actual density of returns, while the red line is the density of the normal distribution with same drift and volatility as earlier. Lines are pretty close to each other.\n\nAnd now onto the histogram on SPY (again same drift and volatility) as fictitious stock above.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(df_spy, aes(return)) + \n  geom_histogram(aes(y = after_stat(density)), alpha = 0.3, fill = 'blue') + \n  geom_density() + \n  geom_vline(xintercept = drift+sigma, color = 'blue', linetype = 3, linewidth = 1) + \n  geom_vline(xintercept = drift-(0.6*sigma),  color = 'blue', linetype = 3, linewidth = 1) + \n  stat_function(fun = dnorm, n = nrow(df), args = list(mean = drift, sd = sigma), color = 'red', size = 1) +\n  scale_y_continuous() + \n  scale_x_continuous(limits = c(-0.055, 0.055), n.breaks = 9)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nAnd here, we clearly see the big disconnect from normality: above expected number of returns at the mean (aka too peaked), less returns next to the mean (between 1 and 2 or 2 1/2 sd) and then higher number of observations than expected in the tails (aka fat tails). Distribution of returns for equity are interesting in that sense: both too peaked and fat tails.\n\n## QQ Plots\n\nAnother way to visually check for normality is to use a quantile-quantile plot (aka QQ-plot). On the y-axis, we have the returns, on the x-axis the theoretical quantiles.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(df, aes(sample = return)) + \n  stat_qq() + \n  stat_qq_line(color = 'blue', linetype = 3, linewidth = 1) + \n  labs(title = 'QQ-Plot for fictious stock returns')\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nAnd now the QQ-plot for the returs of SPY.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(df_spy, aes(sample = return)) + \n  stat_qq() + \n  stat_qq_line(color = 'blue', linetype = 3, linewidth = 1) + \n  labs(title = 'QQ-Plot for SPY returns')\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nOh boy! Again, our second plot clearly indicate how the returns deviate from normality.\n\nThis QQ-plot can also be used to check for asymetry in the distribution of returns. We can see a slightly left skew distribution (a negatively skew distribution).\n\n# Skewness and Kurtosis\n\nSkewness and Kurtosis are the third and fourth [statistical moments](../../time-series/02-statistical-moments/index.qmd) of a distribution.\n\n## Skewness\n\nIdeally, skewness as a measure of symmetry should be close to 0 (perfectly symmetric).\n\nLet's test the symmetry of our 2 sets of returns. Unfortunately, we did not find any function to calculate skewness in base R (seems strange!).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoments::skewness(df$return)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.0398789\n```\n:::\n\n```{.r .cell-code}\nmoments::skewness(df_spy$return)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -0.7418496\n```\n:::\n:::\n\n\nAs expected, our fictitious stock has almost 0 skew (symmetric around the mean), while the SPY has a moderate negative skew (which we could see already on the QQ-plot and histogram.)\n\n## Kurtosis\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmoments::kurtosis(df$return)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.879684\n```\n:::\n\n```{.r .cell-code}\nmoments::kurtosis(df_spy$return)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 12.75883\n```\n:::\n:::\n\n\nAgain, our fictitious asset has kurtosis pretty close to perfect normality (almost 3).  SPY deviate very much from normality and displays leptokurotic kurtosis. \n\n::: {.callout-note}\n\nIn [this post](../../time-series/02-statistical-moments/index.qmd) on the statistical moments, we have showed a couple of transformation methods (log transform and Box-Cox transform) to normalize data.  \n\n:::\n\n# Statistical tests\n\n## Shapiro-Wilk test\n\nShapiro-Wilk test should actually not be used on large data set. Although, we use it here for demonstration purposes, results should be interpreted with a big spoon of salt.\n\nLet's specify our hypothesis: \n\n* $H_0$: the data follows a normal distribution \n* $H_1$: the data does not follow a normal distribution\n\nLet's first test on our fictitious equity.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshapiro.test(df$return)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tShapiro-Wilk normality test\n\ndata:  df$return\nW = 0.99895, p-value = 0.9215\n```\n:::\n:::\n\n\nExpected, as the randomness of our fictitious stock was randomly distributed.\n\nAnd then on the return of SPY\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshapiro.test(df_spy$return)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\n\tShapiro-Wilk normality test\n\ndata:  df_spy$return\nW = 0.894, p-value < 2.2e-16\n```\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}