{
  "hash": "16bcc3fb3c8433729d24490e1fe9d55b",
  "result": {
    "markdown": "---\ntitle: \"Portfolio Optimization Part I (in R)\"\nauthor: \"Francois de Ryckel\"\ndate: \"2023-02-27\"\ncategories: [portfolio, R-code, quant-finance, model]\neditor: source\n---\n\n\nFirst post on portfolio optimization from a quantitative finance lense.  \n\nWe are optimizing a portfolio with *N assets*, where $N \\geq 2$ (N is a positive integer)\n\n::: {#def-weights}\n\nThe weight of each assets *i* in the portfolio is defined as:\n\n$$ W_i = \\frac{\\mbox{Market value of asset i}}{\\mbox{Total market value of portfolio}} $$ {#eq-def-weight}\n:::\n\nOf course, the sum of all the weights should be equal to 1.  \n$$\\sum_{i = 1}^{N} W_i = 1 $$ {#eq-sum-of-weights}\n\nFew assumptions made on the assets. \n\n* each asset has an expected return denoted by $\\mu_i \\mbox{ with } i = 1, 2, \\ldots, N$. In that sense $\\mu_i = E[R_i]$ \n* each asset has standard deviation on their returns denotated by $\\sigma_i \\mbox{ with } i = 1, 2, \\ldots, N$\n* the correlation between asset *i* and asset *j* is denoted by $\\rho_{ij} \\mbox{ with } i,j = 1, 2, \\ldots, N$. In that sense, $\\rho_{ij} = corr(R_i, R_j)$\n\nThe **Mean-Variance Optimization** problem can be formulated in 2 ways: \n\n* Highest possible returns for a given amount of risk \n* Lowest possible amount of risk for a given expected return\n\nReturn is the expected return of the asset and risk is the variance of the returns of the asset. \n\nThe **Risk-Free Asset (RFA)** is the money deposited in a bank account-ish (a secure term-deposit) at a fixed rate **R**. The expected return is thus R and volatitliy is 0.  Also the correlation between the RFA and any other assets is 0. \n\nEach asset can be represented on a 2D-plane with the risk on the x-axis and returns on the y-axis. \n\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/fig-asset-plane-1.png){#fig-asset-plane width=672}\n:::\n:::\n\n\n\nThere are some other assumptions made when trying to construct a mean-variance optimum portfolio: \n\n* results are based on total returns (include dividends, interest paid, etc.)\n* fractional shares are possible\n* can deposit and withdraw money freely at the risk-free rate\n* no restriction on short selling \n* doesn't account for tax, transaction fees, collateral and margins.  \n \n\n# In practice\n\nTo bring these idea into practices, there are a few ways to go about it. \nThe first approach is to have *Monte-Carlo simulations* using historical data for the parameters of the mean and variance. \nAnother approach would be to use numerical methods to find the optimum weights that maximize the sharpe ratio (aka ratio of returns to volatility). \n\n## Create MC simulations of weights to assess mean-variance of a portfolio\n\nLet's get 5 different financial assets: AA, LLY, AMD, SBUX, FDX. Although they are from different industries, it is not a very diverse bunch as they are all from US big companies. \n\nWe already have the assets downloaded and we'll use their closing prices. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readr)      # read_csv()\nlibrary(dplyr)      # select(), arrange(), filter(), mutate(), summarize()\nlibrary(purrr)      # map()\nlibrary(tidyr)      # drop_na(), pivot_wider(), unnest()\nlibrary(glue)       # glue()\n\n# read adjusted closing prices and compute annualized daily returns and sd\nread_prices <- function(ticker) { \n  df <- read_csv(glue('../../raw_data/', {ticker}, '.csv')) |> \n    arrange(date) |> \n    select(date, adj_close = adjClose) |> \n    filter(date > '2018-01-01') |> \n    mutate(ret1d = (adj_close / lag(adj_close, 1)) - 1) |> \n    summarize(mean_ret = mean(ret1d, na.rm = T) * 252 * 100, \n              std_ret = sd(ret1d, na.rm = T) * sqrt(252) * 100)\n}\n\nassets <- c('AA', 'LLY', 'AMD', 'SBUX', 'FDX')\ndf <- tibble(ticker = assets, \n             prices = map(ticker, read_prices)) |> \n  unnest()\n```\n:::\n\n::: {#tbl-mean-variance .cell tbl-cap='Annualized Mean and Standard Deviation of daily returns' tbl-colwidths='[100,200,200]'}\n::: {.cell-output-display}\n`````{=html}\n<table>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Ticker </th>\n   <th style=\"text-align:right;\"> Mean Ret </th>\n   <th style=\"text-align:right;\"> Std of Ret </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> AA </td>\n   <td style=\"text-align:right;\"> 15.90 </td>\n   <td style=\"text-align:right;\"> 60.72 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> LLY </td>\n   <td style=\"text-align:right;\"> 31.79 </td>\n   <td style=\"text-align:right;\"> 29.78 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> AMD </td>\n   <td style=\"text-align:right;\"> 55.31 </td>\n   <td style=\"text-align:right;\"> 56.70 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> SBUX </td>\n   <td style=\"text-align:right;\"> 17.47 </td>\n   <td style=\"text-align:right;\"> 30.66 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> FDX </td>\n   <td style=\"text-align:right;\"> 4.40 </td>\n   <td style=\"text-align:right;\"> 37.53 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n\nFirst, we create the df of returns: \n\n* it's a long df with only ticker, date, daily returns\n* one row per daily observation. \n* we drop first row with no returns \n* the returns df is a wide df with date and tickers as columns, then daily returns as row\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# functions to get daily returns of each assets\ncreate_returns_df <- function(ticker) { \n  df <- read_csv(glue('../../raw_data/', {ticker}, '.csv')) |> \n    arrange(date) |> \n    select(date, adj_close = adjClose) |> \n    filter(date > '2018-01-01') |> \n    mutate(ret1d = (adj_close / lag(adj_close, 1)) - 1) |> \n    select(date, ret1d)\n}\n\n# df of each assets and all their daily returns\ndf <- tibble(ticker = assets, \n             prices = map(ticker, create_returns_df)) |> \n  unnest(cols = c(prices)) |> \n  drop_na()\n\n\nreturns <- df |> arrange(ticker) |> \n  pivot_wider(names_from = ticker, values_from = ret1d)  \n\nhead(returns)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n  date             AA     AMD       FDX       LLY     SBUX\n  <date>        <dbl>   <dbl>     <dbl>     <dbl>    <dbl>\n1 2018-01-03 -0.0121   0.0519  0.0125    0.00543   0.0187 \n2 2018-01-04  0.00367  0.0494  0.0156    0.00446   0.00375\n3 2018-01-05 -0.0112  -0.0198  0.00393   0.0123    0.0115 \n4 2018-01-08  0.0168   0.0337  0.0103   -0.00508  -0.00503\n5 2018-01-09 -0.0145  -0.0375 -0.00339  -0.000813 -0.00219\n6 2018-01-10  0.0363   0.0118  0.000971  0.000465  0.0108 \n```\n:::\n:::\n\n\nTo optimize the mean-variance of the portfolio, we consider the following \n\nWeights of each assets are $w = \\pmatrix{w_1 \\\\ w_2 \\\\ \\vdots \\\\ w_n}$.  \nMean returns of each assets are $\\mu = \\pmatrix{\\mu_1 \\\\ \\mu_2 \\\\ \\vdots \\\\ \\mu_n}$ \n\nThen, the **expected portfolio return** is $\\mu_{\\pi} = w^{T} \\cdot \\mu$ where $w^{T}$ is the transpose of $w$ (aka transforming $w$ from a column vector to a row vector in order to have right dimensions to compute the dot product). \n\nAnd the **expected portfolio variance** is computed by $$\\sigma_{\\pi}^2 = w^T \\cdot \\Sigma \\cdot w$$ where $\\Sigma$ is the covariance matrix. Also, don't forget to square root the variance when using sd: $\\sigma_{\\pi} = \\sqrt{w^T \\cdot \\Sigma \\cdot w}$ \n\nTo put this into code, we first create the matrix of returns,then create the covariance matrix.  Using both matrices, we create a function that return the portfolio mean and variance using the randomly chosen weights. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# this df to provide vectors of expected returns\ndf_stat <- df |> \n  group_by(ticker) |> \n  summarize(mean_ret = mean(ret1d, na.rm = T) * 252) |> \n  ungroup() |> arrange(ticker) \n\nmu = as.matrix(df_stat$mean_ret, nrow = length(assets))\n\n# this df to provide the covariance matrix\n# note how we have also multiplied it by 252\nsigma <- df |> arrange(ticker) |> \n  pivot_wider(names_from = ticker, values_from = ret1d) |> \n  #drop_na() |> \n  select(-date) |> cov() * 252\n\nsigma <- as.matrix(sigma, nrow = length(assets))\n\n# this function to create one simulation using random weights\ncreate_one_portfolio_simulation <- function(n) { \n  # pick random weights\n  weights_rand = runif(length(assets))\n  weights = matrix(weights_rand / sum(weights_rand), nrow = length(assets))\n  \n  #these are textbook formula for return and volat of a portfolio\n  return_pi = as.numeric(t(weights) %*% mu)\n  volat_pi = sqrt(as.numeric((t(weights) %*% sigma) %*% weights))\n  sharpe_ratio = return_pi / volat_pi\n  \n  # wrap everything into a df for later checks / analysis\n  df <- tibble(portf_ret = round(return_pi * 100, 4), portf_volat = round(volat_pi * 100, 4),  \n               weights = round(t(weights) * 100, 4), sharpe_ratio = sharpe_ratio)\n\n  return(df)\n}\n\n#this is really the only inputs to get \nnum_portfolio = 7000\n\nmc_simu = tibble(id = 1:num_portfolio) |> \n  mutate(simul = map(id, create_one_portfolio_simulation)) |> \n  unnest(cols=c(simul)) |> \n  arrange(desc(sharpe_ratio))\n\nhead(mc_simu)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n     id portf_ret portf_volat weights[,1]  [,2]  [,3]  [,4]  [,5] sharpe_ratio\n  <int>     <dbl>       <dbl>       <dbl> <dbl> <dbl> <dbl> <dbl>        <dbl>\n1  6821      34.8        28.3        8.10  27.4  2.85  52.4  9.30         1.23\n2  6864      34.9        28.4        1.32  29.9  5.94  48.1 14.7          1.23\n3  5876      36.5        29.8        6.34  32.9  5.35  51.5  3.92         1.23\n4  3051      34.0        27.8        2.57  26.7  8.54  52.7  9.52         1.22\n5  3947      36.9        30.3        1.08  36.3  1.55  41.4 19.7          1.22\n6  5561      34.7        28.4        2.25  29.8  6.51  47.6 13.8          1.22\n```\n:::\n:::\n\n\n### Vizualisation of mean-variances points\n\nWe have highlithed the portfolio with best mean-variance returns with a red square around its dot. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n\nggplot(mc_simu, aes(x = portf_volat, y = portf_ret)) + \n  geom_point(aes(colour = sharpe_ratio)) + \n  scale_color_distiller(palette=\"Set1\") + \n  geom_point(data = mc_simu[1,], aes(x = portf_volat, y = portf_ret), \n             color = 'red', size = 6, shape=5) + \n  xlab('Portfolio Volatility') + \n  ylab('Portfolio Returns') + \n  labs(title = 'MC simulation for 5 stocks', color = 'Sharpe \\n Ratio') \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}