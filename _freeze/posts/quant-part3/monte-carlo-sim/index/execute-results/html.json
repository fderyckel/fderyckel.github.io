{
  "hash": "4fac5291eed7c2d9a7df01986521e885",
  "result": {
    "markdown": "---\ntitle: \"Modeling Option prices using Monte-Carlo simulations\"\nauthor: \"Francois de Ryckel\"\ndate: \"2023-08-27\"\ndescription: 'Using the BSE and Monte-Carlo Methods to value option prices'\ncategories: [Black-Schole, Risk-Neutrality, Exotic Options, Monte-Carlo]\nimage: 'mc-simulation.png'\neditor: source\ndate-modified: \"2023-07-23\"\n---\n\nRecall Monte-Carlo method exploits the relationship between options prices and expectation under a risk-neutral measure. It is the present value of the expectation (under a risk-neutral measure) of the payoff.  In this sense $$V(S, t) = \\text{PV} \\space \\space \\mathbb{E}^\\mathbb{Q} (Payoff)$$\n\nWe start with the usual SDE (except we use $r$ instead of $\\mu$ as we are under the risk-neutral framework). \n$$dS_t = r S_t dt + \\sigma S_t dW_t$$\nUsing the Euler discretization \n$$S_{t + \\delta t} = S_t \\cdot (1 + r \\delta t + \\sigma \\sqrt{\\delta t} \\phi)$$\n\n\n## Using Python \n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\n\ndef simulate_path(s0, mu, sigma, Time, num_timestep, n_sim): \n  \n  np.random.seed(20230902)\n  \n  S0 = s0\n  r = mu\n  T = Time\n  t = num_timestep \n  n = n_sim \n  \n  #defining dt\n  dt = T/t\n  \n  S = np.zeros((t, n))\n  S[0] = S0\n  \n  for i in range(0, t-1): \n    w = np.random.standard_normal(n)\n    S[i+1] = S[i] * (1 + r * dt + sigma * np.sqrt(dt) * w)\n  \n  return S\n\n```\n:::\n\n\nLet's create a simulation for a quarter of a year (3 months or 63 trading days). \n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nsimulate_path(s0=100, mu=0.045, sigma=0.17, Time=0.25, num_timestep=63, n_sim=100)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\narray([[100.        , 100.        , 100.        , ..., 100.        ,\n        100.        , 100.        ],\n       [ 99.39825714, 100.88405395, 100.17361119, ..., 100.79029332,\n         98.89439673,  99.86236711],\n       [ 99.50936214, 100.97945468,  99.7824842 , ...,  98.66331487,\n         98.67131431, 100.50278255],\n       ...,\n       [100.32398459, 110.16941406,  95.79494772, ..., 101.76681189,\n         91.43131552,  98.94795092],\n       [100.93630069, 111.0365789 ,  94.89177952, ..., 101.32109813,\n         93.37392012,  98.42725475],\n       [101.17836924, 110.76099538,  95.51591487, ..., 101.28364139,\n         92.50938162,  96.80815562]])\n```\n:::\n:::\n\n\nLet's put that into a data frame for further plotting and manipulation\n\nNote each column of the data frame is a simulation.  The number of rows is the number of time steps. \n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nsimulated_paths = pd.DataFrame(simulate_path(s0=100, mu=0.045, sigma=0.17, Time=0.25, num_timestep=63, n_sim=100))\n```\n:::\n\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nsimulated_paths.iloc[-1].hist(bins = 100)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```\n<Axes: >\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-5-output-2.png){width=558 height=411}\n:::\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nplt.plot(simulated_paths)  #plot the first 100 paths\nplt.xlabel('time steps')\nplt.xlim(0, 64)\nplt.ylim(75, 135)\nplt.ylabel('Pries')\nplt.title('Monte-Carlo Simulation of an Asset Price')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-6-output-1.png){width=593 height=449}\n:::\n:::\n\n\nUnder the risk-neutral measure, the value of the option is the discounted value of the expected payoff. \n$$C = e^{rT} \\cdot \\mathbb{E}[max(S_T - K, 0)]$$\n\n* $K$ is the strike price\n\nFor this simulation, we let $K=100$ as well! \n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nK = 100\nr = 0.045\nT = 0.25 \n\nS = simulate_path(s0=100, mu=0.045, sigma=0.17, Time=0.25, num_timestep=63, n_sim=10000)\n\n## calculate payoff for call options \nCo = np.exp(-r*T) * np.mean(np.maximum(0, S[-1]-K))\n## calculate payoff for put options \nPo = np.exp(-r*T) * np.mean(np.maximum(0, K - S[-1]))\n\nprint(f\"European Call Option value is {Co: 0.4f}\")\nprint(f\"European Put Option value is {Po: 0.4f}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nEuropean Call Option value is  3.8587\nEuropean Put Option value is  2.7757\n```\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n\nsT= np.linspace(50,150,100)\n\nfigure, axes = plt.subplots(1, 2, figsize=(20, 6), sharey = True)\ntitle = ['Call payoff', 'Put payoff']\npayoff = [np.maximum(0, sT-K), np.maximum(0, K-sT)] \ncolor = ['green', 'red'] \nlabel = ['Call', 'Put']\n\nfor i in range(2): \n  axes[i].plot(sT, payoff[i], color = color[i], label = label[i])\n  axes[i].set_title(title[i])\n  axes[i].legend()\n\nfigure.suptitle('Option Payoff at Maturity')\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-8-output-1.png){width=1533 height=543}\n:::\n:::\n\n\n# Asian Options\n\nWe are taking the averages of a given asset prices. \n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nA = np.mean(S, axis = 0)    # axis = 0, mean is over the columns ==> results is 1000 means. We had a 1000 simulations of 63 steps. \nB = np.mean(S, axis = 1)    # axis = 1, mean is row by row  ==> results is 63 means\n\nK = 100\nr = 0.045\nT = 0.25 \nS = simulate_path(s0=100, mu=0.045, sigma=0.17, Time=0.25, num_timestep=63, n_sim=10000)\n\n# do not use S[-1] anymore (the last prices), but the average instead (here it is A)\nCo = np.exp(-r * T) * np.mean(np.maximum(0, A - K))\nPo = np.exp(-r * T) * np.mean(np.maximum(0, K - A))\n\nprint(f\"Asian Call Option value is: {Co: 0.4f}\")\nprint(f'Asian Put Option Value is: {Po:0.4f}')\n```\n:::\n\n\n# Barrier options.  \nBarrier options are path dependent.  They'll need another argument \n\n::: {.callout-note}\nIn a paper titled A Continuity Correction for Discrete Barrier Option, Mark Broadie, Paul Glasser- man and Steven Kou have shown us that the discrete barrier options can be priced using continuous barrier formulas by applying a simple continuity correction to the barrier. The correction shifts the barrier away from the underlying by a factor of\n$$exp(\\beta \\sigma \\sqrt{\\delta_t})$$\nwhere $\\beta \\approx 0.5826$\n:::\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nK = 100\nr = 0.045\nsigma = 0.17\nT = 0.25 \nnum_timestep = 63\nnum_sim = 10000\nS = simulate_path(s0=100, mu=0.045, sigma=sigma, Time=T, num_timestep=num_timestep, n_sim=num_sim)\n\n# Let's put the barrier at 117 !  we call it B\nB = 117\ndelta_t = T / num_timestep\nrebate = 10\nvalue = 0\nbeta = 0.5826\n\n# Barrier shift - continuity correction for discrete monitoring\nB_shift = B * np.exp(beta * sigma * np.sqrt(delta_t))\nprint(B_shift)\n\n# finding discounted value of expected payoff\nfor i in range(num_sim): \n  # if final price of one simulation is less that the Barrier shift\n  if S[:,i].max() < B_shift: \n    value += np.maximum(0, S[-1, i] - K)\n  else: \n    value += rebate\n    \nCo = np.exp(-r * T) * (value/num_sim)\nprint(f'The up-and-out Barrier Option value is {Co:04f}')\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n117.73225187428132\nThe up-and-out Barrier Option value is 3.369172\n```\n:::\n:::\n\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nfigure, axes = plt.subplots(1,3, figsize=(20,6), constrained_layout=True)\ntitle = ['Visualising the Barrier Condition', 'Spot Touched Barrier', 'Spot Below Barrier']\naxes[0].plot(S[:,:200])\nfor i in range(200):\n    axes[1].plot(S[:,i]) if S[:,i].max() > B_shift else axes[2].plot(S[:,i])\nfor i in range(3):\n    axes[i].set_title(title[i])\n    axes[i].hlines(B_shift, 0, 65, colors='k', linestyles='dashed')\nfigure.supxlabel('time steps')\nfigure.supylabel('index levels')\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-11-output-1.png){width=1931 height=587}\n:::\n:::\n\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef create_price_path(S0, rfr, sigma, time_horizon, num_steps, num_sim): \n  \n  np.random.seed(18092023)\n\n  dt = time_horizon / num_steps\n\n  S = np.zeros((num_steps, num_sim))\n  S[0] = S0\n\n  for i in range(0,num_steps-1): \n    phi = np.random.standard_normal(num_sim)\n    S[i+1] = S[i] * (1 + rfr * dt + phi * sigma * np.sqrt(dt))\n  \n  return S\n\nS = create_price_path(100, 0.045, 0.17, 1, 252, 10000)\n\n# for a european option.  \n\nK = 100\nr = 0.05\nT = 0.55\n\nC0 = np.exp(-r*T) * np.mean(np.maximum(0, S[-1]-K))\n\nC0\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n9.038910855148245\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}