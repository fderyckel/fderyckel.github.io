{
  "hash": "c98a86c138f564f860a5e2c0fc3e7ddb",
  "result": {
    "markdown": "---\ntitle: \"Black-Schole Equation\"\nauthor: \"Francois de Ryckel\"\ndate: \"2023-07-18\"\ndescription: 'Deriving the Black-Schole Equation and finding its solutions. Application with R and Python'\ncategories: [quant-finance, Black-Schole]\neditor: source\ndate-modified: \"2023-07-23\"\n---\n\n# Deriving the Black-Schole Equation\n\n# Solving the Black-Schole Equation \n\n# The Greeks \n\n| Greek   |   Description                                          | Formula                                 | Call Option  | Put Option  | \n|---------|--------------------------------------------------------|-----------------------------------------|--------------| ------------|\n| Delta   |  Sensitivity of option value to changes in asset price |  $\\frac{\\partial V}{\\partial S}$        | $N(d_1)$     |  $-N(-d_!)$ |\n| Gamma   |  Sensitivity of Delta to changes in asset price        |  $\\frac{\\partial^2 V}{\\partial S^2}$    | $\\frac{N(d_1)}{S \\sigma \\sqrt{t}}$ | |\n| Vega    |  Sensitivity of option value to changes in volatility  |  $\\frac{\\partial V}{\\partial \\sigma}$   | $S N(d_1) \\sqrt{t}$| |\n| Theta   |  Sensitivity of option value to changes in time        |  $\\frac{\\partial V}{\\partial t}$        |  | |\n| Rho     |  Sensitivity of option value to change in risk-free rate |  $\\frac{\\partial V}{\\partial r}$      | $Kte^{-rt} N(d_2)$ | $-Kte^{-rt} N(-d_2)$|\n\n: {tbl-colwidths=\"[15,60,10, 10]\"}\n\n# Create a function for numerical computation  \n\nRecall from above\n\n$$\\frac{\\partial V}{\\partial t} + \\frac{1}{2} \\sigma^2 S \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - rV = 0$$\n\n* V is the option price at the time $t$. So $V = V(S, t)$  \n* S is the asset spot price\n* t is the time to expiry (in years)\n* $\\sigma$ is the asset diffusion term (its stochastic element) \n* $r$ is the annualized continuously compounded risk-free rate (imaginary friend)\n\nIn the case of a **European Call Option with no-dividend**, the BSE has solution: \n\n$$C = S N(d_1) - K e^{-rt} N(d_2)$$\n\nAnd in the case of a **European Put Option with no-dividend**, the BSE has solution: \n$$P = K e^{-rt}N(-d_2) - SN(-d_1)$$\n\nwhere, \n$$d_1 = \\frac{1}{\\sigma \\sqrt{t}} \\left[ ln \\left( \\frac{S}{K} \\right) + \\left( r + \\frac{\\sigma^2}{2} \\right) t \\right]$$\n$$d_2 = d1 - \\sigma \\sqrt{t}$$\n\n$$N(x) = \\frac{1}{\\sqrt{2 \\pi}} \\int_{-\\infty}^{x} e^{\\frac{-1}{2} x^2} dx$$ \n\n* K is the strike price \n\n## Using Python \n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\nimport pandas as pd\nfrom scipy.stats import norm\nimport matplotlib.pyplot as plt \n\n\nclass option_pricing: \n  \n  \"\"\"\n  To price European Style options without dividends\n  \"\"\"\n  \n  def __init__(self, spot, strike, rate, dte, sigma): \n    \n    # assign our variables\n    self.spot = spot\n    self.strike = strike\n    self.rate = rate\n    self.dte = dte    # days to expiration (in years)\n    self.sigma = sigma\n    \n    # to avoid zero division, let not allow strike of 0\n    if self.strike == 0: \n      raise ZeroDivisionError('The Strike Price cannot be 0')\n    else: \n      self._d1_ = (np.log(self.spot / self.strike) + (self.rate + (self.sigma**2 / 2)) * dte) / (self.sigma * self.dte**0.5)\n      self._d2_ = self._d1_ - (self.sigma * self.dte**0.5) \n    \n    for i in ['callPrice', 'putPrice', 'callDelta', 'putDelta', 'gamma']: \n      self.__dict__[i] = None\n      \n    [self.callPrice, self.putPrice] = self._price() \n    [self.callDelta, self.putDelta] = self._delta()\n    self.gamma = self._gamma()\n    \n  def _price(self): \n      if self.sigma == 0 or self.dte == 0: \n        call = maximum(0.0, self.spot - self.strike)\n        put = maximum(0.0, self.strike - self.spot) \n      else: \n        call = (self.spot * norm.cdf(self._d1_)) - (self.strike * np.e**(- self.rate * self.dte) * norm.cdf(self._d2_))\n        put = (self.strike * np.e**(- self.rate * self.dte) * norm.cdf(-self._d2_)) - (self.spot * norm.cdf(-self._d1_))\n      return [call, put] \n    \n  def _delta(self): \n    if self.sigma == 0 or self.dte == 0: \n      call = 1.0 if self.spot > self.strike else 0.0\n      put = -1.0 if self.spot < self.strike else 0.0\n    else: \n      call = norm.cdf(self._d1_)\n      put = -norm.cdf(-self._d1_)\n    return [call, put]\n  \n  def _gamma(self): \n    return norm.cdf(self._d1_) / (self.spot * self.sigma * self.dte**0.5)\n\n```\n:::\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nfrom tabulate import tabulate\n\noption = option_pricing(100, 100, 0, 1, 0.2)\n\nheader = ['Call Price', 'Put Price', 'Call Delta', 'Gamma']\ntable = [[option.callPrice, option.putPrice, option.callDelta, option.gamma]]\nprint(tabulate(table, header))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Call Price    Put Price    Call Delta      Gamma\n------------  -----------  ------------  ---------\n     7.96557      7.96557      0.539828  0.0269914\n```\n:::\n:::\n\n\n## Retrieving option data using Yahoo finance \n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nimport yfinance as yf \n\namd = yf.Ticker('AMD')\namd_hist = amd.history(start = '2022-01-01')\noptions = amd.option_chain('2023-12-15')\n\nfrom datetime import datetime\ndte = (datetime(2023, 12, 15) - datetime.today()).days \n\nlog_returns = np.log(amd_hist['Close'] / amd_hist['Close'].shift(1)).dropna()\nhistorical_vol = log_returns.std() * np.sqrt(dte)\n\nspot = 116; strike = 120; rate = 0.05\n\namd_opt = option_pricing(spot=spot, strike=strike, rate=rate, dte=dte/365, sigma=historical_vol)\n\nprint(f'The BS model for AMD 147 days ahead is {amd_opt.callPrice:0.4f}')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThe BS model for AMD 147 days ahead is 12.1762\n```\n:::\n:::\n\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ndf = options.calls[(options.calls['strike'] >= 90) & (options.calls['strike'] < 150)]\ndf.reset_index(drop = True, inplace = True)\n\ndf1 = pd.DataFrame({'strike': df['strike'], 'price': df['lastPrice'], 'impl_vol': df['impliedVolatility']})\ndf1['delta'] = df1['gamma'] = 0.\n\nfor i in range(len(df1)): \n  df['delta'].iloc[i] = option_pricing(spot=spot, strike=df['strike'].iloc[i], rate, dte=dte, sigma = df1['impl_vol'].iloc[i]).callDelta\n\n```\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nfor i in range(len(df1)):\n    \n    df1['Delta'].iloc[i] = option_pricing(spot,df1['strike'].iloc[i],rate,dte,df1['impl_vol'].iloc[i]).callDelta\n    df1['Gamma'].iloc[i] = option_pricing(spot,df1['strike'].iloc[i],rate,dte,df1['impl_vol'].iloc[i]).gamma\n```\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}