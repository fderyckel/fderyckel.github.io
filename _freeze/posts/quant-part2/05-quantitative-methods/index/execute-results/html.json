{
  "hash": "a5f9e7d3d914793daca8b7b422685d46",
  "result": {
    "markdown": "---\ntitle: \"quantitative Methods\"\nauthor: \"Francois de Ryckel\"\ndate: \"2024-01-21\"\ncategories: [graph, code]\neditor: source\ndate-modified: \"2024-02-21\"\n---\n\n\nStarting here a few examples on how to graph functions, how to solve equations and differential equations with computational methods. \n\n# Basic graphs of a functions. \n\nLet's take the function $$Q(t) = 10 e^{- \\frac{t}{10}}$$  We want to graph this in the interval 0-40 for instance and know what is the value of $Q$ when $t=30$. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'dplyr'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:stats':\n\n    filter, lag\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following objects are masked from 'package:base':\n\n    intersect, setdiff, setequal, union\n```\n:::\n\n```{.r .cell-code}\nlibrary(ggplot2)\ndf <- tibble(x = seq(from = 0, to = 40, length.out = 200)) |> \n  mutate(y = 10 * exp(-x/10))\ndf_point <- tibble(x = 30, y = 10 * exp(-x/10))\n\nggplot(df, aes(x, y)) + \n  geom_line(color = 'blue', size = 1) + \n  geom_point(data = df_point, aes(x, y), color = 'red', size = 3) + \n  geom_text(data = df_point, aes(x+2, y+0.5, label = paste('x = 30, y = ', round(y, 4))), color = 'red')\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n\n# Graphing slope fields from differential equations \n\nSolving $$\\frac{dN}{dt} = r \\cdot N \\cdot \\left( 1 - \\frac{N}{K} \\right)$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(deSolve)\n\nmodel <- function(time, y, parms) {\n  with(as.list(c(y, parms)), {\n    dN <- r * N * (1 - N/K)\n    list(dN)\n  })\n}\n\n\ny = c(N = 0.1)\nparms <- c(r = 0.1, K = 10)\ntimes <- seq(0, 100, 1)\n\nout <- ode(y, times, model, parms)\n\nplot(out)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\nSolving $$\\frac{dS}{dt} = 8 - \\frac{S(t)}{4+t}$$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel <- function(t, S, parms) {\n  with(as.list(c(S, parms)), {\n    dS <- 8 - S/(4+t)\n    list(dS)\n  })\n}\n\nS0 = 32\ntimes <- seq(0, 100, 0.1)\n\nout <- ode(y=S0, times = times, func = model, parms=NULL)\n\nplot(out)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# finding S(t) for specific value of time\nlibrary(dplyr)\nyo <- as_tibble(out) |> select(t = time, S = '1')\n\nyo |> filter(t == 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 2\n  t         S        \n  <deSolve> <deSolve>\n1 20        98.66667 \n```\n:::\n:::\n\n\n\n# Using Python \n\n## Euler's method \n\nLet's define $y' = f(x, y)$ and a small increment $h$ which is a small steps on the interval $[x_0, b]$.  We obtain $h$ by dividing that interval in $n$ eaual parts. Hence $h = \\frac{b - x_0}{n}$.  Finally, we approximate $y$ in the following way: \n$$y_{i+1} = y_i + h \\cdot f(x_i, y_i)$$ \nWe need a starting point: $y(x_0) = y_0$ and $x_0 = 0$ and $x_1 = x_0 + h$ and so on. \n\n### Problem 1 \n\nApproximate the function $$y' + 2y = x^3 \\cdot e^{-2x}$$ at $x = 1.7$ using increment of $h = 0.01$.  This is an initial-value problem with $y(0) = 1$\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\n\n#defining the function first \ndef f(x, y): \n  return(-2*y + x**3 * np.exp(-2*x))\n\n# defining the recurisve loop to approximate y'\n## in our problem: h = 0.01, xn = 1.7\ndef euler_method(f, x0, y0, h, xn): \n  n = np.rint(xn / h).astype(int)\n  x = np.linspace(x0, xn, n) \n  y = np.zeros(n) \n  y[0] = y0 \n  for i in range(1, n):  \n    y[i] = y[i-1] + h * f(x[i-1], y[i-1]) \n  return x, y\n  \n# approximatinig our ODE\nx0=0\ny0=1\nh=0.01\nxn=1.7\nx, y = euler_method(f, x0, y0, h, xn)\n```\n:::\n\n\nAnd bonus we could add some graphs to it \n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport matplotlib.pyplot as plt\nplt.clf()\nplt.plot(x, y)\nplt.xlabel('x')\nplt.ylabel('y')\nplt.title('Approximate solution to an ODE using Euler\\'s method' )\nplt.show()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}