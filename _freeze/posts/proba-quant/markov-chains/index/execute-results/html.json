{
  "hash": "4486844c59291e9fd439741a7d623ebd",
  "result": {
    "markdown": "---\ntitle: \"Markov Chains\"\nauthor: \"Francois de Ryckel\"\ndate: '2022-10-21'\ncategories: [Random Walk, Markov Chain, code, python]\neditor: source\ndate-modified: '2022-10-21'\n---\n\nIntroduction to Markov Chains\n\n::: {.callout-tip appearance=\"simple\"}\n# Markov Chain\n\nEverything that will happen in the future only depends on what is happening right now.\n:::\n\nA Markov chain is a random process with the Markov property. A random process or often called stochastic property is a mathematical object defined as a collection of random variables. A Markov chain has either discrete state space (set of possible values of the random variables) or discrete index set (often representing time) - given the fact, many variations for a Markov chain exists. Usually the term \"Markov chain\" is reserved for a process with a discrete set of times, that is a Discrete Time Markov chain (DTMC).\n\nTo develop better intuition about Markov chain, the simpler version of it is to model a basic random walk.\n\n# Random Walk 101 \n\nThe situation: we will walk 1000 steps. At each step, we flip a fair coin and move 1 step to the right if it is head and one step to the left if it is tail.\n\n## From scratch \n\n::: {#build_basic_random_walk_in_python .cell execution_count=1}\n``` {.python .cell-code}\nimport numpy as np\n\nstart = 0\ny = []\nn = 1000\n\nfor i in range(n): \n  step = np.random.choice([-1, 1], p = [0.5, 0.5])\n  start += step\n  y.append(start)\n\n```\n:::\n\n\n::: {.cell .fig-cap-location-bottom execution_count=2}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\n\nplt.plot(y)\n#plt.xlabel('Number of steps')\n#plt.ylabel(r'$S_{n}$')\n```\n\n::: {.cell-output .cell-output-display}\n![A random walk with a 1000 steps and equal probabilty to go left or right](index_files/figure-html/plot_basic_random_walk_in_python-output-1.png){#plot_basic_random_walk_in_python width=577 height=411}\n:::\n:::\n\n\n## Using financial data \n\nPython code coming from [this post](https://medium.com/the-handbook-of-coding-in-finance/simulating-random-walk-of-stock-prices-with-monte-carlo-simulation-in-python-6e233d841e)\n\nA Monte-Carlo simulation of a random-walk of a stock price does assume that the returns follow a **normal distribution**.  A second assumption is that the past volatility of returns will continue (or be very similar) in the future. \nThis is of course not totally the case.  \n\n### Getting data and feature engineeriing \n\nGetting data using the yfinance package. \n\n::: {#getting_sbux_price_data .cell execution_count=3}\n``` {.python .cell-code}\nimport yfinance as yf\nimport pandas as pd\n\nyo = yf.download(\"SBUX\", start = \"2005-01-01\")\n\nyo.to_csv(\"../../../raw_data/sbux.csv\")\n\nyo['Adj Close'][-1]\n\nyo.info()\n\n```\n:::\n\n\nWe have imported SBUX stock price data and stored them on disk.  We'll retrieve it using pandas and construct our returns and volatility variables. \n\n::: {#get_volatility_in_python .cell execution_count=4}\n``` {.python .cell-code}\nimport pandas as pd\n\nsbux = pd.read_csv(\"../../../raw_data/sbux.csv\")\n\nsbux.tail() \n\n# get the daily returns and then filter on the last 2 years of trading. \n# calculate volatiliy on these last years (not realistic of course)\ndaily_returns = sbux['adjClose'].pct_change()\n#sbux = sbux.tail(505)\ndaily_volat = daily_returns.std()\n\nprint(daily_volat)\n\nsbux.info()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.01969615976089248\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 5821 entries, 0 to 5820\nData columns (total 13 columns):\n #   Column            Non-Null Count  Dtype  \n---  ------            --------------  -----  \n 0   date              5821 non-null   object \n 1   open              5821 non-null   float64\n 2   high              5821 non-null   float64\n 3   low               5821 non-null   float64\n 4   close             5821 non-null   float64\n 5   adjClose          5821 non-null   float64\n 6   volume            5821 non-null   int64  \n 7   unadjustedVolume  5821 non-null   int64  \n 8   change            5821 non-null   float64\n 9   changePercent     5821 non-null   float64\n 10  vwap              5821 non-null   float64\n 11  label             5821 non-null   object \n 12  changeOverTime    5821 non-null   float64\ndtypes: float64(9), int64(2), object(2)\nmemory usage: 591.3+ KB\n```\n:::\n:::\n\n\n### Single simulation \n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nlook_back = 252 \ncount = 0\nprice_list = []\nlast_price = sbux['adjClose'].iloc[-1]\n\nprice = last_price * (1 + np.random.normal(0, daily_volat)) \nprice_list.append(price)\n\nfor y in range(look_back): \n  if count == 251: \n    break\n  price = price_list[count] * (1 + np.random.normal(0, daily_volat))\n  price_list.append(price) \n  count += 1\n  \nplt.plot(price_list)\nplt.show()\n\n#price_list\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/first_simulation_in_python-output-1.png){#first_simulation_in_python width=571 height=411}\n:::\n:::\n\n\nAn here would be another single simulation.  It will of course look vastly different although it is build from the same normal distribution with same mean $\\mu = 0$ and sd $\\sigma = 0$. \n\n::: {.cell execution_count=6}\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/second_simulation_in_python-output-1.png){#second_simulation_in_python width=571 height=411}\n:::\n:::\n\n\nNow we can re-use that code if we want to create 100's of these simulations.  \n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nnum_of_simulations = 100 \nmodel_ahead = 252 \n\ndf = pd.DataFrame()\nlast_price_list = []\n\nfor x in range(num_of_simulations): \n  count = 0\n  price_list = []\n  last_price = sbux.iloc[-1]['adjClose'] \n  price = last_price * (1 + np.random.normal(0, daily_volat)) \n  price_list.append(price) \n  \n  for y in range(model_ahead): \n    if count == 251: \n      break\n    price = price_list[count] * (1 + np.random.normal(0, daily_volat)) \n    price_list.append(price) \n    count += 1\n  \n  df[x] = price_list\n  last_price_list.append(price_list[-1])\n    \n  \nfig = plt.figure()\nfig.suptitle(\"Monte Carlo Simulation for SBUX\") \nplt.plot(df)\nplt.xlabel(\"Day\")\nplt.ylabel(\"Price\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/py_run_many_simlations-output-1.png){#py_run_many_simlations width=585 height=477}\n:::\n:::\n\n\nWith just 10 simulated random-walks on SBUX given the last 17 years of volatility, we can see that price could range between &#36;40 to around &#36;140 dollars over the next 252 trading days (one year).  \n\n### Analysis of our MC simulation \n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nprint(\"Expected price: \", round(np.mean(last_price_list), 2))\nprint(\"Quantile (5%): \", np.percentile(last_price_list, 5))\nprint(\"Quantile (95%): \", np.percentile(last_price_list, 95))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nExpected price:  3.91\nQuantile (5%):  2.067721871499613\nQuantile (95%):  6.312896824025823\n```\n:::\n:::\n\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nplt.hist(last_price_list, bins=10) \nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-10-output-1.png){width=566 height=411}\n:::\n:::\n\n\n# Markov Chain 101 \n\nThe main concept to deal with in a markov chain is a transition matrix.  \n\n## Transition Matrix \n\nIn a transition matrix, the rows are you starting state and columns are your end of state.   \nSo with the below matrix, the probability to go from state A to state A is 0.8 and probability to go from state A to state D is 0.2.  In this sense, all the rows of a transition matrix should always add up to 1.  \n\n::: {#example_of_tranistion_matrix_in_python .cell execution_count=10}\n``` {.python .cell-code}\nstate_A = [0.1, 0.4, 0.3, 0.2, 0]\nstate_B = [0.0, 0.5, 0.5, 0.0, 0]\nstate_C = [0.0, 0.0, 1.0, 0.0, 0]\nstate_D = [0.0, 0.0, 0.0, 0.0, 1.0]\nstate_E = [0.0, 0.0, 0.0, 0.5, 0.5]\n\ntransition_matrix = [state_A, state_B, state_C, state_D, state_E]\n```\n:::\n\n\nWe could also create a function to check if a transition matrix is indeed a properly formatted transition matrix to model a markov chain. \n\n::: {#function_to_check_format_of_tm .cell execution_count=11}\n``` {.python .cell-code}\ndef check_markov_chain(m): \n  for i in range(0, len(m)): \n    if sum(m[i]) != 1: \n      return False\n  print(\"This is a correctly formatted transition matrix\") \n  \ncheck_markov_chain(transition_matrix)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nThis is a correctly formatted transition matrix\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}