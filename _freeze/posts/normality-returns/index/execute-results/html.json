{
  "hash": "0af2090692b433652215d0328e7796a5",
  "result": {
    "markdown": "---\ntitle: \"Normality of asset returns\"\nauthor: \"Francois de Ryckel\"\ndate: \"2023-04-19\"\ncategories: [R-code, quant-finance, normal-distribution]\neditor: source\nimage: 'qqplot-spy.png'\ndate-modified: \"2023-04-21\"\n---\n\n::: {.cell}\n\n:::\n\n\n# Introduction \n\nAs mentioned in one of our [previous posts](../random-behavior-assets/index.qmd), we know that in quantitative finance, assets returns are assumed to be random.  That being said they are not totally normally distributed.  This post is to digg in a bit further in assessing the normality (or non-normality) of equity returns. \n\nLet's start by considering an ETF (low-ish volatility) like the SPY500.  \nTo better illustrate our point, we'll also consider a fictitious stock with random and almost perfectly normally distributed returns. \n\nFrom previous post, returns can be explained with a drift rate + some randomness: \n$$R_i = \\mu \\delta t + \\phi \\sigma \\delta t^{1/2}$$\n\n# Comparing SPY returns with a similar imaginary stock \n\nLet's make some assumptions on how to get the drift rate and volatility of SPY.  Using all the trading sessions since 01 Jan 2020, we'll use the mean historical returns as standard deviation of returns as drift and volatility.   \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_spy <- read_csv('../../raw_data/SPY.csv') |> \n  select(date, adjClose) |> \n  arrange(date) |> \n  mutate(return = log(adjClose / lag(adjClose))) |> \n  filter(date > '2020-01-01')\n\ndrift = mean(df_spy$return) \nsigma = sd(df_spy$return) \n```\n:::\n\n\nSo over the last 3-ish years, SPY had an annualized drift rate of 9.04% with an volatility of 24.4%\n\nLet's consider now an imaginary stock with a similar drift rate and standard deviation as SPY.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(21042023)\nphi = rnorm(831, mean = 0, sd = 1)\ndf <- tibble(time = 1:length(phi), \n             phi = phi, \n             return = drift + sigma * phi)\n\nprices = c(100)\nfor (i in 2:(nrow(df))) {\n  prices[i] = prices[i-1] * (1 + df$return[i])\n}\n\ndf <- add_column(df, prices)\n\nggplot(df, aes(x = time, y = prices)) + \n  geom_line() + \n  labs(title = 'Imaginary Stock', \n       subtitle = 'Same drift as volatility as SPY')\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(df$return)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.000729576\n```\n:::\n\n```{.r .cell-code}\nmean(df_spy$return)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.0003587736\n```\n:::\n:::\n\n\n\n## Visual checks on imaginary stock vs SPY \n\nUsual visual checks for normality are the histogram and the QQ-plot. \n\n### Histograms \n\nLet's see how well the returns stack to our imaginary stock (with close to perfect pseudo-randomness)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(df, aes(return)) + \n  geom_histogram(aes(y = after_stat(density)), alpha = 0.3, fill = 'blue') + \n  geom_density() + \n  stat_function(fun = dnorm, n = nrow(df), args = list(mean = drift, sd = sigma), color = 'red', size = 1) +\n  scale_y_continuous() + \n  scale_x_continuous(limits = c(-0.055, 0.055), n.breaks = 9)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nThe black line is the actual density of returns, while the red line is the density of the normal distribution with same drift and volatility as earlier.   Lines are pretty close to each other.  \n\nAnd now onto the histogram on SPY (again same drift and volatility) as fictitious stock above. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(df_spy, aes(return)) + \n  geom_histogram(aes(y = after_stat(density)), alpha = 0.3, fill = 'blue') + \n  geom_density() + \n  geom_vline(xintercept = drift+sigma, color = 'blue', linetype = 3, linewidth = 1) + \n  geom_vline(xintercept = drift-(0.6*sigma),  color = 'blue', linetype = 3, linewidth = 1) + \n  stat_function(fun = dnorm, n = nrow(df), args = list(mean = drift, sd = sigma), color = 'red', size = 1) +\n  scale_y_continuous() + \n  scale_x_continuous(limits = c(-0.055, 0.055), n.breaks = 9)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nAnd here, we clearly see the big disconnect from normality: above expected number of returns at the mean (aka too peaked), less returns next to the mean (between 1 and 2 or 2 1/2 sd) and then higher number of observations than expected in the tails (aka fat tails).  Distribution of returns for equity are interesting in that sense: both too peaked and fat tails. \n\n### QQ Plots \n\nAnother way to visually check for normality is to use a quantile-quantile plot (aka QQ-plot).  On the y-axis, we have the returns, on the x-axis the theoretical quantiles. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(df, aes(sample = return)) + \n  stat_qq() + \n  stat_qq_line(color = 'blue', linetype = 3, linewidth = 1) + \n  labs(title = 'QQ-Plot for fictious stock returns')\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nAnd now the QQ-plot for the returs of SPY. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(df_spy, aes(sample = return)) + \n  stat_qq() + \n  stat_qq_line(color = 'blue', linetype = 3, linewidth = 1) + \n  labs(title = 'QQ-Plot for SPY returns')\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nOh boy! Again, our second plot clearly indicate how the returns deviate from normality.  \n\nThis QQ-plot can also be used to check for asymetry in the distribution of returns.  We can see a slightly left skew distribution (a negatively skew distribution). \n\n## Kurtosis \n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}