---
title: "Correlation between assets"
---

```{r}
library(dplyr)
library(readr)
library(roll)
```

```{r}
library("reticulate")
virtualenv_create(envname  = "my_env", packages = c("numpy", "scipy", "pandas"))
Sys.setenv(RETICULATE_PYTHON = "../../.virtualenvs/my_env/bin/python")

use_virtualenv("my_env")
py_config()

```


```{r}
# set parameters we will need
num_assets = 3
alpha = 0.99                 # the confidence level
sum_weights = 2*244+135+315. # total value of portfolio
weights = matrix(c(2*244, 135, 315), nrow = num_assets) / sum_weights

mu = matrix(c(50/10000, 30/10000, 20/10000), nrow = num_assets)
rho = matrix(c(1, 0.5, 0.25, 0.5, 1, 0.6, 0.25, 0.6, 1), nrow = num_assets)
volat = c(0.02, 0.03, 0.01)

sigma = (diag(volat) %*% rho) %*% diag(volat)
sigma
#sigma = np.dot(np.diag(volat), rho).dot(np.diag(volat))

VaR = -t(weights) %*% mu + qnorm(alpha) * sqrt((t(weights) %*% sigma) %*% weights)
VaR

Var_V = VaR * sum_weights
Var_V

ES = -t(weights) %*% mu + sqrt((t(weights) %*% sigma) %*% weights) / (1 - alpha) * dnorm(qnorm(alpha))
ES
```

```{r}
alpha = 0.99
time = 5 

weights = c(1/2, 1/2)
mu = c(0, 0)
volat = c(0.01 * sqrt(time), 0.01 * sqrt(time))
rho = matrix(c(1, 0.3, 0.3, 1), nrow = 2)
sigma = (diag(volat) %*% rho) %*% diag(volat)

VaR = t(weights) %*% mu + qnorm(alpha) * sqrt((t(weights) %*% sigma) %*% weights)
VaR * 200000
```


```{r}
pnorm(-2.326)

# return the z-value to have a probability of 1% (always from -inf until z-value)
qnorm(0.01)

```

```{python}
import numpy as np
from scipy.stats import norm

# set parameters we will need
alpha = 0.99        # the confidence level

sum_weights = 2*244+135+315
weights = np.matrix([[2*244], [135], [315]]) / sum_weights   #Need to be a column vector
x = np.matrix([[2*244], [135], [315]]) / sum_weights
mu = np.matrix([[50/10000], [30/10000], [20/10000]])


volat = np.array([0.02, 0.03, 0.01])
rho = np.matrix([[1, 0.5, 0.25], [0.5, 1, 0.6], [0.25, 0.6, 1]])
sigma = np.dot(np.diag(volat), rho).dot(np.diag(volat))

VaR = -weights.T * mu + norm.ppf(alpha) * np.sqrt(weights.T * sigma * weights)

norm.ppf(0.99)
ES_x = -x.T*mu + (np.sqrt(x.T*sigma*x))/(1-alpha)*norm.pdf(norm.ppf(alpha))
ES_x

norm.pdf(norm.ppf(alpha))
norm.ppf(alpha)
```





## Random walk coding practices

```{r}
# Set the number of steps
n_steps <- 100

# Set the probability of moving up or down
prob_up <- 0.5
prob_down <- 1 - prob_up

# Initialize the random walk
random_walk <- numeric(n_steps)
random_walk[1] <- 0 # Starting point

# Simulate the random walk
for (i in 2:n_steps) {
  # Generate a random step up or down
  step <- rbinom(1, 1, prob_up)

  # Update the position in the random walk
  random_walk[i] <- random_walk[i-1] + (2*step-1)
}

# Plot the random walk
plot(random_walk, type="l", xlab="Time", ylab="Position", main="Random Walk Simulation")
```
This is one realization of a random walk. 
```{r}
# create a binomial model.  
# You either get 1 dollars or loose 1 dollars.  (or eighter you go one step up or one step down)
num_steps <- 100 
prob_up <- 0.5
y <- numeric(num_steps)
y[1] <- 0

for (i in 2:num_steps) {
  step <- rbinom(1, 1, prob_up)
  y[i] <- y[i-1] + ((2 * step) - 1)
}
y
plot(y, type="l", xlab="Time", ylab="Position", main="Random Walk Simulation")
```

Using the tidy approach. One realization of a binomial random walk

```{r}
library(tibble)
library(dplyr)
library(ggplot2)
num_steps = 100
prob_up = 0.5

df <- tibble(steps = 1:num_steps, 
             binom_up_down = rbinom(n = 100, size = 1, prob = prob_up)) %>% 
  mutate(up_down = if_else(binom_up_down == 1, 1, -1), 
         position = cumsum(up_down))

ggplot(df, aes(x = steps, y = position)) + 
  geom_line()
```

Using a trinomial distribution now

```{r}
library(purrr)
num_steps = 1000
alpha = 0.28
prob_up = alpha
prob_down = alpha
prob_same = 1 - 2*alpha

# runif(1) take a number between 0 and 1 using a uniform distribution.  
# we then use the prob properties to say if it +1, 0 or -1

df = tibble(steps = 1:num_steps, 
            ones = rep(1, num_steps)) |> 
  mutate(change = map_dbl(ones, runif), 
         up_down = if_else(change < alpha, -1, if_else(change > 1 - alpha, 1, 0)), 
         position = cumsum(up_down))

ggplot(df, aes(x = steps, y = position)) + 
  geom_line()

```

